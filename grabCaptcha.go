package main

import (
	"log"

	"time"

	// "github.com/briandowns/spinner"
	"github.com/go-resty/resty/v2"
	"github.com/tidwall/gjson"
)

var configuration = config{apikey: "***REMOVED***", googlekey: "***REMOVED***", siteurl: "discordapp.com"}

func (user *User) NewKey() string {

	user.auth.Captcha.captchaID = user.newSolve(configuration.apikey, configuration.googlekey, configuration.siteurl)

	log.Println("solveTest: ", user.auth.Captcha.captchaID)
	// s := spinner.New(spinner.CharSets[41], 100*time.Millisecond) // Build our new spinner
	// s.Start()                                                    // Start the spinner
	// s.Suffix = "       Waiting 15 seconds till we request captcha"
	// time.Sleep(15 * time.Second) // Run for some time to simulate work
	// s.Stop()go

	code := user.getSolve(configuration.apikey)
	user.auth.Captcha.captchaKey = code
	// log.Println("id", code)
	return code
}
func (user *User) newSolve(apiKey string, googlekey string, pageurl string) string {
	client := resty.New()
	client.SetQueryParam("key", apiKey)
	client.SetQueryParam("googlekey", googlekey)
	client.SetQueryParam("method", "userrecaptcha")
	client.SetQueryParam("pageurl", pageurl)
	client.SetQueryParam("json", "1")
	resp, err := client.R().Post("https://2captcha.com/in.php")
	if err != nil {
		log.Println(err)
	}
	log.Println(resp.String())

	// var r New
	// json.Unmarshal([]byte(resp.String()), &r)

	r := gjson.Get(resp.String(), "request").String()
	user.auth.Captcha.captchaID = r
	return r

}
func (user *User) getSolve(apiKey string) string {
	client := resty.New()
	client.SetQueryParam("key", apiKey)
	client.SetQueryParam("action", "get")
	client.SetQueryParam("json", "1")
	// res := ""
	// resp, err := client.R().Get("https://2captcha.com/res.php")
	// if err != nil {
	// 	log.Println(err)

	// }
	// var r New
	// json.Unmarshal([]byte(resp.String()), &r)
	check := time.NewTicker(15 * time.Second)

	for {
		select {
		case <-check.C:
			client.SetQueryParam("id", user.auth.Captcha.captchaID)
			resp, err := client.R().Get("https://2captcha.com/res.php")
			if err != nil {
				log.Print("error in getSolve captcha....: ", err)

			}
			log.Println(resp.String())
			errorMsg := gjson.Get(resp.String(), "request")
			if errorMsg.String() == "ERROR_CAPTCHA_UNSOLVABLE" || errorMsg.String() == "ERROR_WRONG_CAPTCHA_ID" {
				user.newSolve(configuration.apikey, configuration.googlekey, configuration.siteurl)

			}
			if gjson.Get(resp.String(), "status").Int() != 1 {
				log.Println("not ready")

			} else {
				r := gjson.Get(resp.String(), "request")
				log.Println(r.String())
				user.auth.Captcha.captchaKey = r.String()

				return user.auth.Captcha.captchaKey
			}

			check = time.NewTicker(5 * time.Second)

		}
	}
	// if gjson.Get(resp.String(), "status").Int() != 1 {
	// 	log.Println("Error still not ready")
	// 	time.Sleep(5 * time.Second)
	// 	getSolve(apiKey, id)

	// } else {
	// 	log.Println("Solved captcha :D")
	// 	log.Println("Solved captcha :D")
	// 	r := gjson.Get(resp.String(), "request")
	// 	log.Println(r.String())
	// 	stuff := &res
	// 	*stuff = r.String()
	// 	return r.String()
	// }
	// return ""

}

// New Generated by https://quicktype.io
type New struct {
	Status  int64  `json:"status"`
	Request string `json:"request"`
}
type Captcha struct {
	captchaID, captchaKey string
}

// CodeKey captcha solve code
//type CodeKey struct {
//	RequestKey string
//	Time       int64
//}

type config struct {
	apikey    string
	googlekey string
	siteurl   string
}
